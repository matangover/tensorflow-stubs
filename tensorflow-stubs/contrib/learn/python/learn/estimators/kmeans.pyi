# Stubs for tensorflow.contrib.learn.python.learn.estimators.kmeans (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.contrib.factorization.python.ops import clustering_ops as clustering_ops
from tensorflow.contrib.learn.python.learn.estimators import estimator as estimator
from tensorflow.contrib.learn.python.learn.estimators.model_fn import ModelFnOps as ModelFnOps
from tensorflow.python.framework import ops as ops
from tensorflow.python.ops import array_ops as array_ops, math_ops as math_ops, state_ops as state_ops
from tensorflow.python.ops.control_flow_ops import with_dependencies as with_dependencies
from tensorflow.python.summary import summary as summary
from tensorflow.python.training import session_run_hook as session_run_hook, training_util as training_util
from tensorflow.python.training.session_run_hook import SessionRunArgs as SessionRunArgs
from tensorflow.python.util.deprecation import deprecated as deprecated
from typing import Any as Any, Optional as Optional

class _LossRelativeChangeHook(session_run_hook.SessionRunHook):
    def __init__(self, tolerance: Any) -> None: ...
    def begin(self) -> None: ...
    def before_run(self, run_context: Any): ...
    def after_run(self, run_context: Any, run_values: Any) -> None: ...

class _InitializeClustersHook(session_run_hook.SessionRunHook):
    def __init__(self, init_op: Any, is_initialized_op: Any, is_chief: Any) -> None: ...
    def after_create_session(self, session: Any, _: Any) -> None: ...

class KMeansClustering(estimator.Estimator):
    SQUARED_EUCLIDEAN_DISTANCE: Any = ...
    COSINE_DISTANCE: Any = ...
    RANDOM_INIT: Any = ...
    KMEANS_PLUS_PLUS_INIT: Any = ...
    SCORES: str = ...
    CLUSTER_IDX: str = ...
    CLUSTERS: str = ...
    ALL_SCORES: str = ...
    LOSS_OP_NAME: str = ...
    def __init__(self, num_clusters: Any, model_dir: Optional[Any] = ..., initial_clusters: Any = ..., distance_metric: Any = ..., random_seed: int = ..., use_mini_batch: bool = ..., mini_batch_steps_per_iteration: int = ..., kmeans_plus_plus_num_retries: int = ..., relative_tolerance: Optional[Any] = ..., config: Optional[Any] = ...) -> None: ...
    def predict_cluster_idx(self, input_fn: Optional[Any] = ...) -> None: ...
    def score(self, input_fn: Optional[Any] = ..., steps: Optional[Any] = ...): ...
    def transform(self, input_fn: Optional[Any] = ..., as_iterable: bool = ...): ...
    def clusters(self): ...
