# Stubs for tensorflow.contrib.learn.python.learn.estimators.dynamic_rnn_estimator (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.contrib import layers as layers
from tensorflow.contrib.layers.python.layers import optimizers as optimizers
from tensorflow.contrib.learn.python.learn.estimators import constants as constants, estimator as estimator, model_fn as model_fn, prediction_key as prediction_key, rnn_common as rnn_common
from tensorflow.python.framework import dtypes as dtypes, ops as ops
from tensorflow.python.ops import array_ops as array_ops, check_ops as check_ops, math_ops as math_ops, rnn as rnn
from tensorflow.python.util import nest as nest
from typing import Any as Any, Optional as Optional

class PredictionType:
    SINGLE_VALUE: int = ...
    MULTIPLE_VALUE: int = ...

def state_tuple_to_dict(state: Any): ...
def dict_to_state_tuple(input_dict: Any, cell: Any): ...
def build_sequence_input(features: Any, sequence_feature_columns: Any, context_feature_columns: Any, weight_collections: Optional[Any] = ..., scope: Optional[Any] = ...): ...
def construct_rnn(initial_state: Any, sequence_input: Any, cell: Any, num_label_columns: Any, dtype: Any = ..., parallel_iterations: int = ..., swap_memory: bool = ...): ...

class DynamicRnnEstimator(estimator.Estimator):
    def __init__(self, problem_type: Any, prediction_type: Any, sequence_feature_columns: Any, context_feature_columns: Optional[Any] = ..., num_classes: Optional[Any] = ..., num_units: Optional[Any] = ..., cell_type: str = ..., optimizer: str = ..., learning_rate: float = ..., predict_probabilities: bool = ..., momentum: Optional[Any] = ..., gradient_clipping_norm: float = ..., dropout_keep_probabilities: Optional[Any] = ..., model_dir: Optional[Any] = ..., feature_engineering_fn: Optional[Any] = ..., config: Optional[Any] = ...) -> None: ...
