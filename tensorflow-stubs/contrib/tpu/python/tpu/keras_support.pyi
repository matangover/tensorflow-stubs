# Stubs for tensorflow.contrib.tpu.python.tpu.keras_support (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import abc as abc
from tensorflow.contrib.framework.python.framework import experimental as experimental
from tensorflow.contrib.tpu.python.ops import tpu_ops as tpu_ops
from tensorflow.contrib.tpu.python.tpu import keras_tpu_variables as keras_tpu_variables, tpu as tpu, tpu_function as tpu_function, tpu_optimizer as tpu_optimizer
from tensorflow.core.protobuf import config_pb2 as config_pb2
from tensorflow.python.data.ops import dataset_ops as dataset_ops, iterator_ops as iterator_ops
from tensorflow.python.eager import context as context
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, errors as errors, ops as ops, tensor_shape as tensor_shape, tensor_spec as tensor_spec
from tensorflow.python.keras import models as models, optimizers as keras_optimizers
from tensorflow.python.keras.engine import base_layer as base_layer, training_arrays as training_arrays, training_utils as training_utils
from tensorflow.python.keras.layers import embeddings as embeddings
from tensorflow.python.keras.utils.generic_utils import make_batches as make_batches, slice_arrays as slice_arrays
from tensorflow.python.ops import array_ops as array_ops, gen_linalg_ops as gen_linalg_ops, math_ops as math_ops, random_ops as random_ops, variable_scope as variable_scope, variables as variables
from typing import Any as Any, Optional as Optional

def setup_tpu_session(cluster_resolver: Any) -> None: ...
def get_tpu_system_metadata(tpu_cluster_resolver: Any): ...

class TPUDistributionStrategy:
    def __init__(self, tpu_cluster_resolver: Optional[Any] = ..., using_single_core: bool = ...) -> None: ...

class TPUAssignment:
    def __init__(self, worker_name: Any, num_cores: Any) -> None: ...
    @property
    def worker_name(self): ...
    @property
    def num_towers(self): ...

class TPUEmbedding(embeddings.Embedding):
    def build(self, input_shape: Any): ...
    def call(self, inputs: Any): ...

class KerasCrossShardOptimizer(keras_optimizers.Optimizer):
    def __init__(self, opt: Any, name: str = ...) -> None: ...
    def get_updates(self, loss: Any, params: Any): ...
    def get_gradients(self, loss: Any, params: Any): ...
    def get_weights(self): ...
    def get_config(self): ...
    def __getattr__(self, key: Any): ...

class TPUModelOp: ...

class TPURewriteContext:
    def __init__(self, input_map: Any) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...

class SizedInfeed: ...

class TPUInfeedInstance(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def make_input_specs(self, input_tensors: Any) -> Any: ...
    def make_feed_dict(self, tpu_model_op: Any) -> None: ...

class TPUInfeedManager(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def make_infeed_instance(self, inputs: Any) -> Any: ...
    @abc.abstractmethod
    def build_infeed_from_input_specs(self, input_specs: Any, execution_mode: Any) -> Any: ...

class TPUNumpyInfeedManager(TPUInfeedManager):
    class NumpyInfeedInstance(TPUInfeedInstance):
        def __init__(self, sharded_inputs: Any) -> None: ...
        def make_input_specs(self, input_tensors: Any): ...
        def make_feed_dict(self, tpu_model_op: Any): ...
    def __init__(self, tpu_assignment: Any) -> None: ...
    def make_infeed_instance(self, inputs: Any): ...
    def build_infeed_from_input_specs(self, input_specs: Any, execution_mode: Any): ...

class TPUDatasetInfeedManager(TPUInfeedManager):
    class DatasetInfeedInstance(TPUInfeedInstance):
        def __init__(self, input_specs: Any) -> None: ...
        def make_input_specs(self, input_tensors: Any): ...
        def make_feed_dict(self, tpu_model_op: Any): ...
    def __init__(self, dataset: Any, tpu_assignment: Any, mode: Any) -> None: ...
    @property
    def dummy_x(self): ...
    @property
    def dummy_y(self): ...
    def make_infeed_instance(self, inputs: Any): ...
    def build_infeed_from_input_specs(self, input_specs: Any, execution_mode: Any): ...

class TPUFunction:
    model: Any = ...
    execution_mode: Any = ...
    def __init__(self, model: Any, execution_mode: Any, tpu_assignment: Any) -> None: ...
    def __call__(self, inputs: Any): ...
    def pipeline_run(self, cur_step_inputs: Any, next_step_inputs: Any): ...

class KerasTPUModel(models.Model):
    predict_function: Any = ...
    test_function: Any = ...
    train_function: Any = ...
    def __init__(self, cpu_model: Any, strategy: Any) -> None: ...
    def get_config(self): ...
    def compile(self, optimizer: Any, loss: Optional[Any] = ..., metrics: Optional[Any] = ..., loss_weights: Optional[Any] = ..., sample_weight_mode: Optional[Any] = ..., weighted_metrics: Optional[Any] = ..., target_tensors: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def fit(self, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_split: float = ..., validation_data: Optional[Any] = ..., shuffle: bool = ..., class_weight: Optional[Any] = ..., sample_weight: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., validation_steps: Optional[Any] = ..., **kwargs: Any): ...
    def evaluate(self, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., verbose: int = ..., sample_weight: Optional[Any] = ..., steps: Optional[Any] = ...): ...
    def predict(self, x: Any, batch_size: Optional[Any] = ..., verbose: int = ..., steps: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ...): ...
    @property
    def optimizer(self): ...
    @optimizer.setter
    def optimizer(self, optimizer: Any) -> None: ...
    @property
    def cpu_optimizer(self): ...
    def sync_to_cpu(self): ...
    def get_weights(self): ...
    def save_weights(self, *args: Any, **kw: Any): ...
    def save(self, *args: Any, **kw: Any): ...
    def set_weights(self, weights: Any) -> None: ...
    def load_weights(self, filepath: Any, by_name: bool = ...) -> None: ...

def tpu_model(model: Any, strategy: Optional[Any] = ...): ...
