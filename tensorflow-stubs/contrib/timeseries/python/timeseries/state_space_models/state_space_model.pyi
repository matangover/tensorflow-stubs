# Stubs for tensorflow.contrib.timeseries.python.timeseries.state_space_models.state_space_model (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import abc as abc
from tensorflow.contrib.layers.python.layers import layers as layers
from tensorflow.contrib.timeseries.python.timeseries import math_utils as math_utils, model as model, model_utils as model_utils
from tensorflow.contrib.timeseries.python.timeseries.feature_keys import TrainEvalFeatures as TrainEvalFeatures
from tensorflow.contrib.timeseries.python.timeseries.state_space_models import kalman_filter as kalman_filter
from tensorflow.python.estimator import estimator_lib as estimator_lib
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, ops as ops
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, gen_math_ops as gen_math_ops, linalg_ops as linalg_ops, math_ops as math_ops, variable_scope as variable_scope
from typing import Any as Any, Optional as Optional

class StateSpaceModelConfiguration:
    def __new__(cls, num_features: int = ..., use_observation_noise: bool = ..., dtype: Any = ..., covariance_prior_fn: Any = ..., bayesian_prior_weighting: bool = ..., filtering_postprocessor: Optional[Any] = ..., trainable_start_state: bool = ..., exogenous_noise_increases: bool = ..., exogenous_noise_decreases: bool = ..., exogenous_feature_columns: Optional[Any] = ..., exogenous_update_condition: Optional[Any] = ..., filtering_maximum_posterior_variance_ratio: float = ..., filtering_minimum_posterior_variance: float = ..., transition_covariance_initial_log_scale_bias: Any = ..., static_unrolling_window_size_threshold: Optional[Any] = ...): ...

class StateSpaceModel(model.SequentialTimeSeriesModel, metaclass=abc.ABCMeta):
    prior_state_mean: Any = ...
    prior_state_var: Any = ...
    state_transition_noise_covariance: Any = ...
    def __init__(self, configuration: Any) -> None: ...
    def transition_power_noise_accumulator(self, num_steps: Any): ...
    def transition_to_powers(self, powers: Any): ...
    def initialize_graph(self, input_statistics: Optional[Any] = ...) -> None: ...
    def get_prior_covariance(self): ...
    def get_prior_mean(self): ...
    def random_model_parameters(self, seed: Optional[Any] = ...): ...
    def generate(self, number_of_series: Any, series_length: Any, model_parameters: Optional[Any] = ..., seed: Optional[Any] = ..., add_observation_noise: Optional[Any] = ...): ...
    @abc.abstractmethod
    def get_state_transition(self) -> Any: ...
    @abc.abstractmethod
    def get_noise_transform(self) -> Any: ...
    @abc.abstractmethod
    def get_observation_model(self, times: Any) -> Any: ...
    def get_broadcasted_observation_model(self, times: Any): ...
    def get_state_transition_noise_covariance(self, minimum_initial_variance: float = ...): ...
    def get_observation_noise_covariance(self, minimum_initial_variance: float = ...): ...
    def get_start_state(self): ...
    def get_features_for_timesteps(self, timesteps: Any): ...

class StateSpaceEnsemble(StateSpaceModel):
    def __init__(self, ensemble_members: Any, configuration: Any) -> None: ...
    def transition_to_powers(self, powers: Any): ...
    def random_model_parameters(self, seed: Optional[Any] = ...): ...
    def get_prior_mean(self): ...
    def get_state_transition(self): ...
    def get_noise_transform(self): ...
    def get_observation_model(self, times: Any) -> None: ...
    def get_broadcasted_observation_model(self, times: Any): ...

class StateSpaceIndependentEnsemble(StateSpaceEnsemble):
    def transition_power_noise_accumulator(self, num_steps: Any): ...
    def get_prior_covariance(self): ...
    def get_state_transition_noise_covariance(self): ...

class StateSpaceCorrelatedFeaturesEnsemble(StateSpaceEnsemble):
    def __init__(self, ensemble_members: Any, configuration: Any) -> None: ...
    def transition_power_noise_accumulator(self, num_steps: Any): ...
    def get_broadcasted_observation_model(self, times: Any): ...
