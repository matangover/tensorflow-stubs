# Stubs for tensorflow.python.data.experimental.kernel_tests.serialization.dataset_serialization_test_base (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.python.data.ops import iterator_ops as iterator_ops
from tensorflow.python.framework import dtypes as dtypes, errors as errors, ops as ops, sparse_tensor as sparse_tensor
from tensorflow.python.ops import lookup_ops as lookup_ops, variables as variables
from tensorflow.python.platform import gfile as gfile, test as test
from tensorflow.python.training import checkpoint_management as checkpoint_management
from tensorflow.python.util import nest as nest
from typing import Any as Any, Optional as Optional

def remove_variants(get_next_op: Any): ...

class DatasetSerializationTestBase(test.TestCase):
    def tearDown(self) -> None: ...
    def run_core_tests(self, ds_fn1: Any, ds_fn2: Any, num_outputs: Any, sparse_tensors: bool = ...) -> None: ...
    def verify_unused_iterator(self, ds_fn: Any, num_outputs: Any, sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_fully_used_iterator(self, ds_fn: Any, num_outputs: Any, sparse_tensors: bool = ...) -> None: ...
    def verify_exhausted_iterator(self, ds_fn: Any, num_outputs: Any, sparse_tensors: bool = ...) -> None: ...
    def verify_init_before_restore(self, ds_fn: Any, num_outputs: Any, sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_multiple_breaks(self, ds_fn: Any, num_outputs: Any, num_breaks: int = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_reset_restored_iterator(self, ds_fn: Any, num_outputs: Any, break_point: Optional[Any] = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_restore_in_modified_graph(self, ds_fn1: Any, ds_fn2: Any, num_outputs: Any, break_point: Optional[Any] = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_restore_in_empty_graph(self, ds_fn: Any, num_outputs: Any, break_point: Optional[Any] = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def verify_error_on_save(self, ds_fn: Any, num_outputs: Any, error: Any, break_point: Optional[Any] = ..., sparse_tensors: bool = ...) -> None: ...
    def verify_run_with_breaks(self, ds_fn: Any, break_points: Any, num_outputs: Any, init_before_restore: bool = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ...) -> None: ...
    def gen_outputs(self, ds_fn: Any, break_points: Any, num_outputs: Any, ckpt_saved: bool = ..., init_before_restore: bool = ..., sparse_tensors: bool = ..., verify_exhausted: bool = ..., save_checkpoint_at_end: bool = ...): ...
    def match(self, expected: Any, actual: Any) -> None: ...
    def does_not_match(self, expected: Any, actual: Any) -> None: ...
    def gen_break_points(self, num_outputs: Any, num_samples: int = ...): ...
