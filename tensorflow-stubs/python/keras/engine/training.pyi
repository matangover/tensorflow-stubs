# Stubs for tensorflow.python.keras.engine.training (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.python.data.ops import dataset_ops as dataset_ops, iterator_ops as iterator_ops
from tensorflow.python.data.ops.dataset_ops import Dataset as Dataset
from tensorflow.python.eager import context as context
from tensorflow.python.framework import errors as errors, ops as ops, tensor_util as tensor_util
from tensorflow.python.keras import losses as losses, optimizers as optimizers
from tensorflow.python.keras.engine import base_layer as base_layer, distributed_training_utils as distributed_training_utils, training_arrays as training_arrays, training_distributed as training_distributed, training_eager as training_eager, training_generator as training_generator, training_utils as training_utils
from tensorflow.python.keras.engine.network import Network as Network
from tensorflow.python.keras.utils import data_utils as data_utils
from tensorflow.python.keras.utils.generic_utils import slice_arrays as slice_arrays
from tensorflow.python.ops import math_ops as math_ops, weights_broadcast_ops as weights_broadcast_ops
from tensorflow.python.util import nest as nest
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

class Model(Network):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    optimizer: Any = ...
    loss: Any = ...
    metrics: Any = ...
    loss_weights: Any = ...
    sample_weight_mode: Any = ...
    weighted_metrics: Any = ...
    target_tensors: Any = ...
    loss_functions: Any = ...
    loss_weights_list: Any = ...
    total_loss: Any = ...
    targets: Any = ...
    train_function: Any = ...
    test_function: Any = ...
    predict_function: Any = ...
    def compile(self, optimizer: Any, loss: Optional[Any] = ..., metrics: Optional[Any] = ..., loss_weights: Optional[Any] = ..., sample_weight_mode: Optional[Any] = ..., weighted_metrics: Optional[Any] = ..., target_tensors: Optional[Any] = ..., distribute: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def fit(self, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_split: float = ..., validation_data: Optional[Any] = ..., shuffle: bool = ..., class_weight: Optional[Any] = ..., sample_weight: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., validation_steps: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ..., **kwargs: Any): ...
    def evaluate(self, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., verbose: int = ..., sample_weight: Optional[Any] = ..., steps: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ...): ...
    def predict(self, x: Any, batch_size: Optional[Any] = ..., verbose: int = ..., steps: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ...): ...
    def train_on_batch(self, x: Any, y: Optional[Any] = ..., sample_weight: Optional[Any] = ..., class_weight: Optional[Any] = ...): ...
    def test_on_batch(self, x: Any, y: Optional[Any] = ..., sample_weight: Optional[Any] = ...): ...
    def predict_on_batch(self, x: Any): ...
    def fit_generator(self, generator: Any, steps_per_epoch: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_data: Optional[Any] = ..., validation_steps: Optional[Any] = ..., class_weight: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ..., shuffle: bool = ..., initial_epoch: int = ...): ...
    def evaluate_generator(self, generator: Any, steps: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ..., verbose: int = ...): ...
    def predict_generator(self, generator: Any, steps: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ..., verbose: int = ...): ...

class DistributedCallbackModel(Model):
    def __init__(self, model: Any) -> None: ...
    def set_original_model(self, orig_model: Any) -> None: ...
    def save_weights(self, filepath: Any, overwrite: bool = ..., save_format: Optional[Any] = ...) -> None: ...
    def save(self, filepath: Any, overwrite: bool = ..., include_optimizer: bool = ...) -> None: ...
    def load_weights(self, filepath: Any, by_name: bool = ...) -> None: ...
    def __getattr__(self, item: Any) -> None: ...
