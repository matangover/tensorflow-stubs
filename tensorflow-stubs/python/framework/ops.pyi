# Stubs for tensorflow.python.framework.ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import threading as threading
from collections import namedtuple as namedtuple
from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2, function_pb2 as function_pb2, graph_pb2 as graph_pb2, node_def_pb2 as node_def_pb2, op_def_pb2 as op_def_pb2, versions_pb2 as versions_pb2
from tensorflow.core.protobuf import config_pb2 as config_pb2
from tensorflow.python.eager import context as context, core as core, tape as tape
from tensorflow.python.framework import c_api_util as c_api_util, cpp_shape_inference_pb2 as cpp_shape_inference_pb2, dtypes as dtypes, error_interpolation as error_interpolation, errors as errors, op_def_registry as op_def_registry, registry as registry, tensor_shape as tensor_shape, traceable_stack as traceable_stack, versions as versions
from tensorflow.python.ops import control_flow_util as control_flow_util
from tensorflow.python.platform import app as app
from tensorflow.python.util import compat as compat, decorator_utils as decorator_utils, deprecation as deprecation, function_utils as function_utils, lock_util as lock_util, memory as memory, tf_contextlib as tf_contextlib, tf_stack as tf_stack
from tensorflow.python.util.deprecation import deprecated_args as deprecated_args
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

def tensor_id(tensor: Any): ...

class _UserDeviceSpec:
    display_name: Any = ...
    function: Any = ...
    def __init__(self, device_name_or_function: Any) -> None: ...

class _NullContextmanager:
    def __enter__(self) -> None: ...
    def __exit__(self, type_arg: Any, value_arg: Any, traceback_arg: Any): ...

def is_dense_tensor_like(t: Any): ...
def register_dense_tensor_like_type(tensor_type: Any) -> None: ...
def uid(): ...
def numpy_text(tensor: Any, is_repr: bool = ...): ...

class _TensorLike: ...

class Tensor(_TensorLike):
    OVERLOADABLE_OPERATORS: Any = ...
    def __init__(self, op: Any, value_index: Any, dtype: Any) -> None: ...
    @property
    def op(self): ...
    @property
    def dtype(self): ...
    @property
    def graph(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    @property
    def shape(self): ...
    def __iter__(self) -> None: ...
    def get_shape(self): ...
    def set_shape(self, shape: Any) -> None: ...
    @property
    def value_index(self): ...
    def consumers(self): ...
    def __hash__(self): ...
    def __eq__(self, other: Any): ...
    def __copy__(self): ...
    __array_priority__: int = ...
    def __bool__(self) -> None: ...
    def __nonzero__(self) -> None: ...
    def eval(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...): ...

class _EagerTensorBase(Tensor):
    @property
    def dtype(self): ...
    def numpy(self): ...
    def __int__(self): ...
    def __float__(self): ...
    def __index__(self): ...
    def __array__(self, dtype: Optional[Any] = ...): ...
    def __format__(self, format_spec: Any): ...
    def __reduce__(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    @property
    def ndim(self): ...
    def cpu(self): ...
    def gpu(self, gpu_index: int = ...): ...
    def __bool__(self): ...
    def __nonzero__(self): ...
    def set_shape(self, shape: Any) -> None: ...
    @property
    def op(self) -> None: ...
    @property
    def graph(self) -> None: ...
    @property
    def name(self) -> None: ...
    @property
    def value_index(self) -> None: ...
    def consumers(self) -> None: ...
    def eval(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...) -> None: ...

EagerTensor: Any

def convert_to_tensor(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., preferred_dtype: Optional[Any] = ...): ...
def internal_convert_to_tensor(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ..., preferred_dtype: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def internal_convert_n_to_tensor(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ..., preferred_dtype: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def convert_n_to_tensor(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., preferred_dtype: Optional[Any] = ...): ...
def convert_to_tensor_or_indexed_slices(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def internal_convert_to_tensor_or_indexed_slices(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ...): ...
def internal_convert_n_to_tensor_or_indexed_slices(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ...): ...
def convert_n_to_tensor_or_indexed_slices(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def register_tensor_conversion_function(base_type: Any, conversion_func: Any, priority: int = ...) -> None: ...

class IndexedSlices(_TensorLike):
    def __init__(self, values: Any, indices: Any, dense_shape: Optional[Any] = ...) -> None: ...
    @property
    def values(self): ...
    @property
    def indices(self): ...
    @property
    def dense_shape(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    @property
    def op(self): ...
    @property
    def dtype(self): ...
    @property
    def graph(self): ...
    def __neg__(self): ...

IndexedSlicesValue = namedtuple('IndexedSlicesValue', ['values', 'indices', 'dense_shape'])

class Operation:
    def __init__(self, node_def: Any, g: Any, inputs: Optional[Any] = ..., output_types: Optional[Any] = ..., control_inputs: Optional[Any] = ..., input_types: Optional[Any] = ..., original_op: Optional[Any] = ..., op_def: Optional[Any] = ...) -> None: ...
    def colocation_groups(self): ...
    def values(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    @property
    def outputs(self): ...
    class _InputList:
        def __init__(self, inputs: Any) -> None: ...
        def __iter__(self): ...
        def __len__(self): ...
        def __bool__(self): ...
        __nonzero__: Any = ...
        def __getitem__(self, i: Any): ...
    @property
    def inputs(self): ...
    @property
    def control_inputs(self): ...
    @property
    def type(self): ...
    @property
    def graph(self): ...
    @property
    def node_def(self): ...
    @property
    def op_def(self): ...
    @property
    def traceback(self): ...
    @property
    def traceback_with_start_lines(self): ...
    def get_attr(self, name: Any): ...
    def run(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...) -> None: ...

class RegisterGradient:
    def __init__(self, op_type: Any) -> None: ...
    def __call__(self, f: Any): ...

def NotDifferentiable(op_type: Any) -> None: ...
NoGradient = NotDifferentiable

def get_gradient_function(op: Any): ...

class RegisterShape:
    def __init__(self, op_type: Any) -> None: ...
    def __call__(self, f: Any): ...

def set_shape_and_handle_data_for_outputs(op: Any) -> None: ...

class OpStats:
    statistic_type: Any = ...
    value: Any = ...
    def __init__(self, statistic_type: Any, value: Optional[Any] = ...) -> None: ...
    @property
    def statistic_type(self): ...
    @statistic_type.setter
    def statistic_type(self, statistic_type: Any) -> None: ...
    @property
    def value(self): ...
    @value.setter
    def value(self, value: Any) -> None: ...
    def __iadd__(self, other: Any): ...

class RegisterStatistics:
    def __init__(self, op_type: Any, statistic_type: Any) -> None: ...
    def __call__(self, f: Any): ...

def get_stats_for_node_def(graph: Any, node: Any, statistic_type: Any): ...

class Graph:
    def __init__(self) -> None: ...
    @property
    def version(self): ...
    @property
    def graph_def_versions(self): ...
    @property
    def seed(self): ...
    @seed.setter
    def seed(self, seed: Any) -> None: ...
    @property
    def finalized(self): ...
    def finalize(self) -> None: ...
    def as_graph_def(self, from_version: Optional[Any] = ..., add_shapes: bool = ...): ...
    @property
    def building_function(self): ...
    def create_op(self, op_type: Any, inputs: Any, dtypes: Any, input_types: Optional[Any] = ..., name: Optional[Any] = ..., attrs: Optional[Any] = ..., op_def: Optional[Any] = ..., compute_shapes: bool = ..., compute_device: bool = ...): ...
    def as_graph_element(self, obj: Any, allow_tensor: bool = ..., allow_operation: bool = ...): ...
    def get_operations(self): ...
    def get_operation_by_name(self, name: Any): ...
    def get_tensor_by_name(self, name: Any): ...
    def as_default(self): ...
    @property
    def collections(self): ...
    def add_to_collection(self, name: Any, value: Any) -> None: ...
    def add_to_collections(self, names: Any, value: Any) -> None: ...
    def get_collection_ref(self, name: Any): ...
    def get_collection(self, name: Any, scope: Optional[Any] = ...): ...
    def get_all_collection_keys(self): ...
    def clear_collection(self, name: Any) -> None: ...
    def name_scope(self, name: Any) -> None: ...
    def unique_name(self, name: Any, mark_as_used: bool = ...): ...
    def get_name_scope(self): ...
    def colocate_with(self, op: Any, ignore_existing: bool = ...) -> None: ...
    def device(self, device_name_or_function: Any) -> None: ...
    def container(self, container_name: Any) -> None: ...
    class _ControlDependenciesController:
        def __init__(self, graph: Any, control_inputs: Any) -> None: ...
        def __enter__(self) -> None: ...
        def __exit__(self, unused_type: Any, unused_value: Any, unused_traceback: Any) -> None: ...
        @property
        def control_inputs(self): ...
        def add_op(self, op: Any) -> None: ...
        def op_in_group(self, op: Any): ...
    def control_dependencies(self, control_inputs: Any): ...
    def gradient_override_map(self, op_type_map: Any) -> None: ...
    def prevent_feeding(self, tensor: Any) -> None: ...
    def is_feedable(self, tensor: Any): ...
    def prevent_fetching(self, op: Any) -> None: ...
    def is_fetchable(self, tensor_or_op: Any): ...
    def switch_to_thread_local(self) -> None: ...

def device(device_name_or_function: Any): ...
def container(container_name: Any): ...
def colocate_with(op: Any, ignore_existing: bool = ...): ...
def control_dependencies(control_inputs: Any): ...

class _DefaultStack(threading.local):
    stack: Any = ...
    def __init__(self) -> None: ...
    def get_default(self): ...
    def reset(self) -> None: ...
    def is_cleared(self): ...
    @property
    def enforce_nesting(self): ...
    @enforce_nesting.setter
    def enforce_nesting(self, value: Any) -> None: ...
    def get_controller(self, default: Any) -> None: ...

def default_session(session: Any): ...
def get_default_session(): ...

class _DefaultGraphStack(_DefaultStack):
    def __init__(self) -> None: ...
    def get_default(self): ...
    def reset(self) -> None: ...
    def get_controller(self, default: Any) -> None: ...

def init_scope() -> None: ...
def enable_eager_execution(config: Optional[Any] = ..., device_policy: Optional[Any] = ..., execution_mode: Optional[Any] = ...): ...
def enable_eager_execution_internal(config: Optional[Any] = ..., device_policy: Optional[Any] = ..., execution_mode: Optional[Any] = ..., server_def: Optional[Any] = ...) -> None: ...
def eager_run(main: Optional[Any] = ..., argv: Optional[Any] = ...) -> None: ...
def reset_default_graph() -> None: ...
def get_default_graph(): ...
def has_default_graph(): ...
def get_name_scope(): ...

class GraphKeys:
    GLOBAL_VARIABLES: str = ...
    LOCAL_VARIABLES: str = ...
    METRIC_VARIABLES: str = ...
    MODEL_VARIABLES: str = ...
    TRAINABLE_VARIABLES: str = ...
    SUMMARIES: str = ...
    QUEUE_RUNNERS: str = ...
    TABLE_INITIALIZERS: str = ...
    ASSET_FILEPATHS: str = ...
    MOVING_AVERAGE_VARIABLES: str = ...
    REGULARIZATION_LOSSES: str = ...
    CONCATENATED_VARIABLES: str = ...
    SAVERS: str = ...
    WEIGHTS: str = ...
    BIASES: str = ...
    ACTIVATIONS: str = ...
    UPDATE_OPS: str = ...
    LOSSES: str = ...
    SAVEABLE_OBJECTS: str = ...
    RESOURCES: str = ...
    LOCAL_RESOURCES: str = ...
    TRAINABLE_RESOURCE_VARIABLES: str = ...
    INIT_OP: str = ...
    LOCAL_INIT_OP: str = ...
    READY_OP: str = ...
    READY_FOR_LOCAL_INIT_OP: str = ...
    SUMMARY_OP: str = ...
    GLOBAL_STEP: str = ...
    EVAL_STEP: str = ...
    TRAIN_OP: str = ...
    COND_CONTEXT: str = ...
    WHILE_CONTEXT: str = ...
    def VARIABLES(cls): ...

def dismantle_graph(graph: Any) -> None: ...
def add_to_collection(name: Any, value: Any) -> None: ...
def add_to_collections(names: Any, value: Any) -> None: ...
def get_collection_ref(key: Any): ...
def get_collection(key: Any, scope: Optional[Any] = ...): ...
def get_all_collection_keys(): ...

name_scope_cache: Any

class name_scope:
    @property
    def name(self): ...
    def __init__(self, name: Any, default_name: Optional[Any] = ..., values: Optional[Any] = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type_arg: Any, value_arg: Any, traceback_arg: Any): ...

def strip_name_scope(name: Any, export_scope: Any): ...
def prepend_name_scope(name: Any, import_scope: Any): ...
def op_scope(values: Any, name: Any, default_name: Optional[Any] = ...) -> None: ...
def register_proto_function(collection_name: Any, proto_type: Optional[Any] = ..., to_proto: Optional[Any] = ..., from_proto: Optional[Any] = ...) -> None: ...
def get_collection_proto_type(collection_name: Any): ...
def get_to_proto_function(collection_name: Any): ...
def get_from_proto_function(collection_name: Any): ...
