# Stubs for tensorflow.python.ops.gen_sparse_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import namedtuple as namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

def add_many_sparse_to_tensors_map(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def add_many_sparse_to_tensors_map_eager_fallback(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def add_sparse_to_tensors_map(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def add_sparse_to_tensors_map_eager_fallback(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _DeserializeManySparseOutput = namedtuple('DeserializeManySparse', <ERROR>)

def deserialize_many_sparse(serialized_sparse: Any, dtype: Any, name: Optional[Any] = ...): ...
def deserialize_many_sparse_eager_fallback(serialized_sparse: Any, dtype: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _DeserializeSparseOutput = namedtuple('DeserializeSparse', <ERROR>)

def deserialize_sparse(serialized_sparse: Any, dtype: Any, name: Optional[Any] = ...): ...
def deserialize_sparse_eager_fallback(serialized_sparse: Any, dtype: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def serialize_many_sparse(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, out_type: Any = ..., name: Optional[Any] = ...): ...
def serialize_many_sparse_eager_fallback(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, out_type: Any = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def serialize_sparse(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, out_type: Any = ..., name: Optional[Any] = ...): ...
def serialize_sparse_eager_fallback(sparse_indices: Any, sparse_values: Any, sparse_shape: Any, out_type: Any = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseAddOutput = namedtuple('SparseAdd', <ERROR>)

def sparse_add(a_indices: Any, a_values: Any, a_shape: Any, b_indices: Any, b_values: Any, b_shape: Any, thresh: Any, name: Optional[Any] = ...): ...
def sparse_add_eager_fallback(a_indices: Any, a_values: Any, a_shape: Any, b_indices: Any, b_values: Any, b_shape: Any, thresh: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseAddGradOutput = namedtuple('SparseAddGrad', <ERROR>)

def sparse_add_grad(backprop_val_grad: Any, a_indices: Any, b_indices: Any, sum_indices: Any, name: Optional[Any] = ...): ...
def sparse_add_grad_eager_fallback(backprop_val_grad: Any, a_indices: Any, b_indices: Any, sum_indices: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseConcatOutput = namedtuple('SparseConcat', <ERROR>)

def sparse_concat(indices: Any, values: Any, shapes: Any, concat_dim: Any, name: Optional[Any] = ...): ...
def sparse_concat_eager_fallback(indices: Any, values: Any, shapes: Any, concat_dim: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseCrossOutput = namedtuple('SparseCross', <ERROR>)

def sparse_cross(indices: Any, values: Any, shapes: Any, dense_inputs: Any, hashed_output: Any, num_buckets: Any, hash_key: Any, out_type: Any, internal_type: Any, name: Optional[Any] = ...): ...
def sparse_cross_eager_fallback(indices: Any, values: Any, shapes: Any, dense_inputs: Any, hashed_output: Any, num_buckets: Any, hash_key: Any, out_type: Any, internal_type: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_dense_cwise_add(sp_indices: Any, sp_values: Any, sp_shape: Any, dense: Any, name: Optional[Any] = ...): ...
def sparse_dense_cwise_add_eager_fallback(sp_indices: Any, sp_values: Any, sp_shape: Any, dense: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_dense_cwise_div(sp_indices: Any, sp_values: Any, sp_shape: Any, dense: Any, name: Optional[Any] = ...): ...
def sparse_dense_cwise_div_eager_fallback(sp_indices: Any, sp_values: Any, sp_shape: Any, dense: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_dense_cwise_mul(sp_indices: Any, sp_values: Any, sp_shape: Any, dense: Any, name: Optional[Any] = ...): ...
def sparse_dense_cwise_mul_eager_fallback(sp_indices: Any, sp_values: Any, sp_shape: Any, dense: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseFillEmptyRowsOutput = namedtuple('SparseFillEmptyRows', <ERROR>)

def sparse_fill_empty_rows(indices: Any, values: Any, dense_shape: Any, default_value: Any, name: Optional[Any] = ...): ...
def sparse_fill_empty_rows_eager_fallback(indices: Any, values: Any, dense_shape: Any, default_value: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseFillEmptyRowsGradOutput = namedtuple('SparseFillEmptyRowsGrad', <ERROR>)

def sparse_fill_empty_rows_grad(reverse_index_map: Any, grad_values: Any, name: Optional[Any] = ...): ...
def sparse_fill_empty_rows_grad_eager_fallback(reverse_index_map: Any, grad_values: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_reduce_max(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...
def sparse_reduce_max_eager_fallback(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseReduceMaxSparseOutput = namedtuple('SparseReduceMaxSparse', <ERROR>)

def sparse_reduce_max_sparse(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...
def sparse_reduce_max_sparse_eager_fallback(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_reduce_sum(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...
def sparse_reduce_sum_eager_fallback(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseReduceSumSparseOutput = namedtuple('SparseReduceSumSparse', <ERROR>)

def sparse_reduce_sum_sparse(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...
def sparse_reduce_sum_sparse_eager_fallback(input_indices: Any, input_values: Any, input_shape: Any, reduction_axes: Any, keep_dims: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseReorderOutput = namedtuple('SparseReorder', <ERROR>)

def sparse_reorder(input_indices: Any, input_values: Any, input_shape: Any, name: Optional[Any] = ...): ...
def sparse_reorder_eager_fallback(input_indices: Any, input_values: Any, input_shape: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseReshapeOutput = namedtuple('SparseReshape', <ERROR>)

def sparse_reshape(input_indices: Any, input_shape: Any, new_shape: Any, name: Optional[Any] = ...): ...
def sparse_reshape_eager_fallback(input_indices: Any, input_shape: Any, new_shape: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseSliceOutput = namedtuple('SparseSlice', <ERROR>)

def sparse_slice(indices: Any, values: Any, shape: Any, start: Any, size: Any, name: Optional[Any] = ...): ...
def sparse_slice_eager_fallback(indices: Any, values: Any, shape: Any, start: Any, size: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_slice_grad(backprop_val_grad: Any, input_indices: Any, input_start: Any, output_indices: Any, name: Optional[Any] = ...): ...
def sparse_slice_grad_eager_fallback(backprop_val_grad: Any, input_indices: Any, input_start: Any, output_indices: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_softmax(sp_indices: Any, sp_values: Any, sp_shape: Any, name: Optional[Any] = ...): ...
def sparse_softmax_eager_fallback(sp_indices: Any, sp_values: Any, sp_shape: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseSparseMaximumOutput = namedtuple('SparseSparseMaximum', <ERROR>)

def sparse_sparse_maximum(a_indices: Any, a_values: Any, a_shape: Any, b_indices: Any, b_values: Any, b_shape: Any, name: Optional[Any] = ...): ...
def sparse_sparse_maximum_eager_fallback(a_indices: Any, a_values: Any, a_shape: Any, b_indices: Any, b_values: Any, b_shape: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseSparseMinimumOutput = namedtuple('SparseSparseMinimum', <ERROR>)

def sparse_sparse_minimum(a_indices: Any, a_values: Any, a_shape: Any, b_indices: Any, b_values: Any, b_shape: Any, name: Optional[Any] = ...): ...
def sparse_sparse_minimum_eager_fallback(a_indices: Any, a_values: Any, a_shape: Any, b_indices: Any, b_values: Any, b_shape: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _SparseSplitOutput = namedtuple('SparseSplit', <ERROR>)

def sparse_split(split_dim: Any, indices: Any, values: Any, shape: Any, num_split: Any, name: Optional[Any] = ...): ...
def sparse_split_eager_fallback(split_dim: Any, indices: Any, values: Any, shape: Any, num_split: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_tensor_dense_add(a_indices: Any, a_values: Any, a_shape: Any, b: Any, name: Optional[Any] = ...): ...
def sparse_tensor_dense_add_eager_fallback(a_indices: Any, a_values: Any, a_shape: Any, b: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_tensor_dense_mat_mul(a_indices: Any, a_values: Any, a_shape: Any, b: Any, adjoint_a: bool = ..., adjoint_b: bool = ..., name: Optional[Any] = ...): ...
def sparse_tensor_dense_mat_mul_eager_fallback(a_indices: Any, a_values: Any, a_shape: Any, b: Any, adjoint_a: bool = ..., adjoint_b: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_to_dense(sparse_indices: Any, output_shape: Any, sparse_values: Any, default_value: Any, validate_indices: bool = ..., name: Optional[Any] = ...): ...
def sparse_to_dense_eager_fallback(sparse_indices: Any, output_shape: Any, sparse_values: Any, default_value: Any, validate_indices: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _TakeManySparseFromTensorsMapOutput = namedtuple('TakeManySparseFromTensorsMap', <ERROR>)

def take_many_sparse_from_tensors_map(sparse_handles: Any, dtype: Any, container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def take_many_sparse_from_tensors_map_eager_fallback(sparse_handles: Any, dtype: Any, container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
