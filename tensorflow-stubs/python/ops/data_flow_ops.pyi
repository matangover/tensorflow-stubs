# Stubs for tensorflow.python.ops.data_flow_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.python.ops.gen_data_flow_ops import *
from tensorflow.python.eager import context as context
from tensorflow.python.framework import ops as ops, random_seed as random_seed, tensor_shape as tensor_shape, tensor_util as tensor_util
from tensorflow.python.lib.io import python_io as python_io
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, gen_data_flow_ops as gen_data_flow_ops, math_ops as math_ops, resource_variable_ops as resource_variable_ops
from tensorflow.python.util import deprecation as deprecation
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

class QueueBase:
    def __init__(self, dtypes: Any, shapes: Any, names: Any, queue_ref: Any) -> None: ...
    @staticmethod
    def from_list(index: Any, queues: Any): ...
    @property
    def queue_ref(self): ...
    @property
    def name(self): ...
    @property
    def dtypes(self): ...
    @property
    def shapes(self): ...
    @property
    def names(self): ...
    def enqueue(self, vals: Any, name: Optional[Any] = ...): ...
    def enqueue_many(self, vals: Any, name: Optional[Any] = ...): ...
    def dequeue(self, name: Optional[Any] = ...): ...
    def dequeue_many(self, n: Any, name: Optional[Any] = ...): ...
    def dequeue_up_to(self, n: Any, name: Optional[Any] = ...): ...
    def close(self, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...
    def is_closed(self, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...

class RandomShuffleQueue(QueueBase):
    def __init__(self, capacity: Any, min_after_dequeue: Any, dtypes: Any, shapes: Optional[Any] = ..., names: Optional[Any] = ..., seed: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ...) -> None: ...

class FIFOQueue(QueueBase):
    def __init__(self, capacity: Any, dtypes: Any, shapes: Optional[Any] = ..., names: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ...) -> None: ...

class PaddingFIFOQueue(QueueBase):
    def __init__(self, capacity: Any, dtypes: Any, shapes: Any, names: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ...) -> None: ...

class PriorityQueue(QueueBase):
    def __init__(self, capacity: Any, types: Any, shapes: Optional[Any] = ..., names: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ...) -> None: ...

class Barrier:
    def __init__(self, types: Any, shapes: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ...) -> None: ...
    @property
    def barrier_ref(self): ...
    @property
    def name(self): ...
    def insert_many(self, component_index: Any, keys: Any, values: Any, name: Optional[Any] = ...): ...
    def take_many(self, num_elements: Any, allow_small_batch: bool = ..., timeout: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def close(self, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...
    def ready_size(self, name: Optional[Any] = ...): ...
    def incomplete_size(self, name: Optional[Any] = ...): ...

class ConditionalAccumulatorBase:
    def __init__(self, dtype: Any, shape: Any, accumulator_ref: Any) -> None: ...
    @property
    def accumulator_ref(self): ...
    @property
    def name(self): ...
    @property
    def dtype(self): ...
    def num_accumulated(self, name: Optional[Any] = ...): ...
    def set_global_step(self, new_global_step: Any, name: Optional[Any] = ...): ...

class ConditionalAccumulator(ConditionalAccumulatorBase):
    def __init__(self, dtype: Any, shape: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ..., reduction_type: str = ...) -> None: ...
    def apply_grad(self, grad: Any, local_step: int = ..., name: Optional[Any] = ...): ...
    def take_grad(self, num_required: Any, name: Optional[Any] = ...): ...

class SparseConditionalAccumulator(ConditionalAccumulatorBase):
    def __init__(self, dtype: Any, shape: Optional[Any] = ..., shared_name: Optional[Any] = ..., name: str = ..., reduction_type: str = ...) -> None: ...
    def apply_indexed_slices_grad(self, grad: Any, local_step: int = ..., name: Optional[Any] = ...): ...
    def apply_grad(self, grad_indices: Any, grad_values: Any, grad_shape: Optional[Any] = ..., local_step: int = ..., name: Optional[Any] = ...): ...
    def take_grad(self, num_required: Any, name: Optional[Any] = ...): ...
    def take_indexed_slices_grad(self, num_required: Any, name: Optional[Any] = ...): ...

class BaseStagingArea:
    def __init__(self, dtypes: Any, shapes: Optional[Any] = ..., names: Optional[Any] = ..., shared_name: Optional[Any] = ..., capacity: int = ..., memory_limit: int = ...) -> None: ...
    @property
    def name(self): ...
    @property
    def dtypes(self): ...
    @property
    def shapes(self): ...
    @property
    def names(self): ...
    @property
    def capacity(self): ...
    @property
    def memory_limit(self): ...

class StagingArea(BaseStagingArea):
    def __init__(self, dtypes: Any, shapes: Optional[Any] = ..., names: Optional[Any] = ..., shared_name: Optional[Any] = ..., capacity: int = ..., memory_limit: int = ...) -> None: ...
    def put(self, values: Any, name: Optional[Any] = ...): ...
    def get(self, name: Optional[Any] = ...): ...
    def peek(self, index: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def clear(self, name: Optional[Any] = ...): ...

class MapStagingArea(BaseStagingArea):
    def __init__(self, dtypes: Any, shapes: Optional[Any] = ..., names: Optional[Any] = ..., shared_name: Optional[Any] = ..., ordered: bool = ..., capacity: int = ..., memory_limit: int = ...) -> None: ...
    def put(self, key: Any, vals: Any, indices: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def peek(self, key: Any, indices: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def get(self, key: Optional[Any] = ..., indices: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def incomplete_size(self, name: Optional[Any] = ...): ...
    def clear(self, name: Optional[Any] = ...): ...

class RecordInput:
    def __init__(self, file_pattern: Any, batch_size: int = ..., buffer_size: int = ..., parallelism: int = ..., shift_ratio: int = ..., seed: int = ..., name: Optional[Any] = ..., batches: Optional[Any] = ..., compression_type: Optional[Any] = ...) -> None: ...
    def get_yield_op(self): ...
