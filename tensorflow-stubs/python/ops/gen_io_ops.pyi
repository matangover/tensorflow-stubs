# Stubs for tensorflow.python.ops.gen_io_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import namedtuple as namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

def fixed_length_record_reader(record_bytes: Any, header_bytes: int = ..., footer_bytes: int = ..., hop_bytes: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def fixed_length_record_reader_v2(record_bytes: Any, header_bytes: int = ..., footer_bytes: int = ..., hop_bytes: int = ..., container: str = ..., shared_name: str = ..., encoding: str = ..., name: Optional[Any] = ...): ...
def fixed_length_record_reader_v2_eager_fallback(record_bytes: Any, header_bytes: int = ..., footer_bytes: int = ..., hop_bytes: int = ..., container: str = ..., shared_name: str = ..., encoding: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def identity_reader(container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def identity_reader_v2(container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def identity_reader_v2_eager_fallback(container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def lmdb_reader(container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def matching_files(pattern: Any, name: Optional[Any] = ...): ...
def matching_files_eager_fallback(pattern: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def merge_v2_checkpoints(checkpoint_prefixes: Any, destination_prefix: Any, delete_old_dirs: bool = ..., name: Optional[Any] = ...): ...
def merge_v2_checkpoints_eager_fallback(checkpoint_prefixes: Any, destination_prefix: Any, delete_old_dirs: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def read_file(filename: Any, name: Optional[Any] = ...): ...
def read_file_eager_fallback(filename: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def reader_num_records_produced(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_num_records_produced_v2(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_num_records_produced_v2_eager_fallback(reader_handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def reader_num_work_units_completed(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_num_work_units_completed_v2(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_num_work_units_completed_v2_eager_fallback(reader_handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _ReaderReadOutput = namedtuple('ReaderRead', <ERROR>)

def reader_read(reader_handle: Any, queue_handle: Any, name: Optional[Any] = ...): ...

# _ReaderReadUpToOutput = namedtuple('ReaderReadUpTo', <ERROR>)

def reader_read_up_to(reader_handle: Any, queue_handle: Any, num_records: Any, name: Optional[Any] = ...): ...

# _ReaderReadUpToV2Output = namedtuple('ReaderReadUpToV2', <ERROR>)

def reader_read_up_to_v2(reader_handle: Any, queue_handle: Any, num_records: Any, name: Optional[Any] = ...): ...
def reader_read_up_to_v2_eager_fallback(reader_handle: Any, queue_handle: Any, num_records: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _ReaderReadV2Output = namedtuple('ReaderReadV2', <ERROR>)

def reader_read_v2(reader_handle: Any, queue_handle: Any, name: Optional[Any] = ...): ...
def reader_read_v2_eager_fallback(reader_handle: Any, queue_handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def reader_reset(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_reset_v2(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_reset_v2_eager_fallback(reader_handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def reader_restore_state(reader_handle: Any, state: Any, name: Optional[Any] = ...): ...
def reader_restore_state_v2(reader_handle: Any, state: Any, name: Optional[Any] = ...): ...
def reader_restore_state_v2_eager_fallback(reader_handle: Any, state: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def reader_serialize_state(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_serialize_state_v2(reader_handle: Any, name: Optional[Any] = ...): ...
def reader_serialize_state_v2_eager_fallback(reader_handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def restore(file_pattern: Any, tensor_name: Any, dt: Any, preferred_shard: int = ..., name: Optional[Any] = ...): ...
def restore_eager_fallback(file_pattern: Any, tensor_name: Any, dt: Any, preferred_shard: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def restore_slice(file_pattern: Any, tensor_name: Any, shape_and_slice: Any, dt: Any, preferred_shard: int = ..., name: Optional[Any] = ...): ...
def restore_slice_eager_fallback(file_pattern: Any, tensor_name: Any, shape_and_slice: Any, dt: Any, preferred_shard: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def restore_v2(prefix: Any, tensor_names: Any, shape_and_slices: Any, dtypes: Any, name: Optional[Any] = ...): ...
def restore_v2_eager_fallback(prefix: Any, tensor_names: Any, shape_and_slices: Any, dtypes: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def save(filename: Any, tensor_names: Any, data: Any, name: Optional[Any] = ...): ...
def save_eager_fallback(filename: Any, tensor_names: Any, data: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def save_slices(filename: Any, tensor_names: Any, shapes_and_slices: Any, data: Any, name: Optional[Any] = ...): ...
def save_slices_eager_fallback(filename: Any, tensor_names: Any, shapes_and_slices: Any, data: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def save_v2(prefix: Any, tensor_names: Any, shape_and_slices: Any, tensors: Any, name: Optional[Any] = ...): ...
def save_v2_eager_fallback(prefix: Any, tensor_names: Any, shape_and_slices: Any, tensors: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sharded_filename(basename: Any, shard: Any, num_shards: Any, name: Optional[Any] = ...): ...
def sharded_filename_eager_fallback(basename: Any, shard: Any, num_shards: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sharded_filespec(basename: Any, num_shards: Any, name: Optional[Any] = ...): ...
def sharded_filespec_eager_fallback(basename: Any, num_shards: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tf_record_reader(container: str = ..., shared_name: str = ..., compression_type: str = ..., name: Optional[Any] = ...): ...
def tf_record_reader_v2(container: str = ..., shared_name: str = ..., compression_type: str = ..., name: Optional[Any] = ...): ...
def tf_record_reader_v2_eager_fallback(container: str = ..., shared_name: str = ..., compression_type: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def text_line_reader(skip_header_lines: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def text_line_reader_v2(skip_header_lines: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def text_line_reader_v2_eager_fallback(skip_header_lines: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def whole_file_reader(container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def whole_file_reader_v2(container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def whole_file_reader_v2_eager_fallback(container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def write_file(filename: Any, contents: Any, name: Optional[Any] = ...): ...
def write_file_eager_fallback(filename: Any, contents: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
