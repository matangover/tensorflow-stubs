# Stubs for tensorflow.python.ops.gen_data_flow_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import namedtuple as namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

def accumulator_apply_gradient(handle: Any, local_step: Any, gradient: Any, name: Optional[Any] = ...): ...
def accumulator_num_accumulated(handle: Any, name: Optional[Any] = ...): ...
def accumulator_set_global_step(handle: Any, new_global_step: Any, name: Optional[Any] = ...): ...
def accumulator_take_gradient(handle: Any, num_required: Any, dtype: Any, name: Optional[Any] = ...): ...
def barrier(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def barrier_close(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...
def barrier_incomplete_size(handle: Any, name: Optional[Any] = ...): ...
def barrier_insert_many(handle: Any, keys: Any, values: Any, component_index: Any, name: Optional[Any] = ...): ...
def barrier_ready_size(handle: Any, name: Optional[Any] = ...): ...

# _BarrierTakeManyOutput = namedtuple('BarrierTakeMany', <ERROR>)

def barrier_take_many(handle: Any, num_elements: Any, component_types: Any, allow_small_batch: bool = ..., wait_for_incomplete: bool = ..., timeout_ms: int = ..., name: Optional[Any] = ...): ...
def conditional_accumulator(dtype: Any, shape: Any, container: str = ..., shared_name: str = ..., reduction_type: str = ..., name: Optional[Any] = ...): ...
def delete_session_tensor(handle: Any, name: Optional[Any] = ...): ...
def delete_session_tensor_eager_fallback(handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def dynamic_partition(data: Any, partitions: Any, num_partitions: Any, name: Optional[Any] = ...): ...
def dynamic_partition_eager_fallback(data: Any, partitions: Any, num_partitions: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def dynamic_stitch(indices: Any, data: Any, name: Optional[Any] = ...): ...
def dynamic_stitch_eager_fallback(indices: Any, data: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def fifo_queue(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def fifo_queue_v2(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def fifo_queue_v2_eager_fallback(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def fake_queue(resource: Any, name: Optional[Any] = ...): ...
def get_session_handle(value: Any, name: Optional[Any] = ...): ...
def get_session_handle_eager_fallback(value: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def get_session_handle_v2(value: Any, name: Optional[Any] = ...): ...
def get_session_handle_v2_eager_fallback(value: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def get_session_tensor(handle: Any, dtype: Any, name: Optional[Any] = ...): ...
def get_session_tensor_eager_fallback(handle: Any, dtype: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def map_clear(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_clear_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def map_incomplete_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_incomplete_size_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def map_peek(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_peek_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def map_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_size_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def map_stage(key: Any, indices: Any, values: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_stage_eager_fallback(key: Any, indices: Any, values: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def map_unstage(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_unstage_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _MapUnstageNoKeyOutput = namedtuple('MapUnstageNoKey', <ERROR>)

def map_unstage_no_key(indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def map_unstage_no_key_eager_fallback(indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def ordered_map_clear(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_clear_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def ordered_map_incomplete_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_incomplete_size_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def ordered_map_peek(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_peek_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def ordered_map_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_size_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def ordered_map_stage(key: Any, indices: Any, values: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_stage_eager_fallback(key: Any, indices: Any, values: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def ordered_map_unstage(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_unstage_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _OrderedMapUnstageNoKeyOutput = namedtuple('OrderedMapUnstageNoKey', <ERROR>)

def ordered_map_unstage_no_key(indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def ordered_map_unstage_no_key_eager_fallback(indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def padding_fifo_queue(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def padding_fifo_queue_v2(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def padding_fifo_queue_v2_eager_fallback(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def parallel_dynamic_stitch(indices: Any, data: Any, name: Optional[Any] = ...): ...
def parallel_dynamic_stitch_eager_fallback(indices: Any, data: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def priority_queue(shapes: Any, component_types: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def priority_queue_v2(shapes: Any, component_types: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def priority_queue_v2_eager_fallback(shapes: Any, component_types: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_close(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...
def queue_close_v2(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...
def queue_close_v2_eager_fallback(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_dequeue(handle: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_dequeue_many(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_dequeue_many_v2(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_dequeue_many_v2_eager_fallback(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_dequeue_up_to(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_dequeue_up_to_v2(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_dequeue_up_to_v2_eager_fallback(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_dequeue_v2(handle: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_dequeue_v2_eager_fallback(handle: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_enqueue(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_enqueue_many(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_enqueue_many_v2(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_enqueue_many_v2_eager_fallback(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_enqueue_v2(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...
def queue_enqueue_v2_eager_fallback(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_is_closed(handle: Any, name: Optional[Any] = ...): ...
def queue_is_closed_v2(handle: Any, name: Optional[Any] = ...): ...
def queue_is_closed_v2_eager_fallback(handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def queue_size(handle: Any, name: Optional[Any] = ...): ...
def queue_size_v2(handle: Any, name: Optional[Any] = ...): ...
def queue_size_v2_eager_fallback(handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def random_shuffle_queue(component_types: Any, shapes: Any = ..., capacity: int = ..., min_after_dequeue: int = ..., seed: int = ..., seed2: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def random_shuffle_queue_v2(component_types: Any, shapes: Any = ..., capacity: int = ..., min_after_dequeue: int = ..., seed: int = ..., seed2: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def random_shuffle_queue_v2_eager_fallback(component_types: Any, shapes: Any = ..., capacity: int = ..., min_after_dequeue: int = ..., seed: int = ..., seed2: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def record_input(file_pattern: Any, file_random_seed: int = ..., file_shuffle_shift_ratio: int = ..., file_buffer_size: int = ..., file_parallelism: int = ..., batch_size: int = ..., compression_type: str = ..., name: Optional[Any] = ...): ...
def record_input_eager_fallback(file_pattern: Any, file_random_seed: int = ..., file_shuffle_shift_ratio: int = ..., file_buffer_size: int = ..., file_parallelism: int = ..., batch_size: int = ..., compression_type: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def sparse_accumulator_apply_gradient(handle: Any, local_step: Any, gradient_indices: Any, gradient_values: Any, gradient_shape: Any, has_known_shape: Any, name: Optional[Any] = ...): ...

# _SparseAccumulatorTakeGradientOutput = namedtuple('SparseAccumulatorTakeGradient', <ERROR>)

def sparse_accumulator_take_gradient(handle: Any, num_required: Any, dtype: Any, name: Optional[Any] = ...): ...
def sparse_conditional_accumulator(dtype: Any, shape: Any, container: str = ..., shared_name: str = ..., reduction_type: str = ..., name: Optional[Any] = ...): ...
def stack_close(handle: Any, name: Optional[Any] = ...): ...
def stack_close_v2(handle: Any, name: Optional[Any] = ...): ...
def stack_close_v2_eager_fallback(handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stack_pop(handle: Any, elem_type: Any, name: Optional[Any] = ...): ...
def stack_pop_v2(handle: Any, elem_type: Any, name: Optional[Any] = ...): ...
def stack_pop_v2_eager_fallback(handle: Any, elem_type: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stack_push(handle: Any, elem: Any, swap_memory: bool = ..., name: Optional[Any] = ...): ...
def stack_push_v2(handle: Any, elem: Any, swap_memory: bool = ..., name: Optional[Any] = ...): ...
def stack_push_v2_eager_fallback(handle: Any, elem: Any, swap_memory: bool = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stack_v2(max_size: Any, elem_type: Any, stack_name: str = ..., name: Optional[Any] = ...): ...
def stack_v2_eager_fallback(max_size: Any, elem_type: Any, stack_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stage(values: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def stage_eager_fallback(values: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stage_clear(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def stage_clear_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stage_peek(index: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def stage_peek_eager_fallback(index: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def stage_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def stage_size_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array(size: Any, dtype: Any, dynamic_size: bool = ..., clear_after_read: bool = ..., tensor_array_name: str = ..., element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_close(handle: Any, name: Optional[Any] = ...): ...
def tensor_array_close_v2(handle: Any, name: Optional[Any] = ...): ...
def tensor_array_close_v2_eager_fallback(handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_close_v3(handle: Any, name: Optional[Any] = ...): ...
def tensor_array_close_v3_eager_fallback(handle: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _TensorArrayConcatOutput = namedtuple('TensorArrayConcat', <ERROR>)

def tensor_array_concat(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ...): ...

# _TensorArrayConcatV2Output = namedtuple('TensorArrayConcatV2', <ERROR>)

def tensor_array_concat_v2(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_concat_v2_eager_fallback(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _TensorArrayConcatV3Output = namedtuple('TensorArrayConcatV3', <ERROR>)

def tensor_array_concat_v3(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_concat_v3_eager_fallback(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_gather(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_gather_v2(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_gather_v2_eager_fallback(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_gather_v3(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_gather_v3_eager_fallback(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_grad(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ...): ...
def tensor_array_grad_v2(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ...): ...
def tensor_array_grad_v2_eager_fallback(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _TensorArrayGradV3Output = namedtuple('TensorArrayGradV3', <ERROR>)

def tensor_array_grad_v3(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ...): ...
def tensor_array_grad_v3_eager_fallback(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _TensorArrayGradWithShapeOutput = namedtuple('TensorArrayGradWithShape', <ERROR>)

def tensor_array_grad_with_shape(handle: Any, flow_in: Any, shape_to_prepend: Any, source: Any, name: Optional[Any] = ...): ...
def tensor_array_grad_with_shape_eager_fallback(handle: Any, flow_in: Any, shape_to_prepend: Any, source: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_pack(handle: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def tensor_array_read(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ...): ...
def tensor_array_read_v2(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ...): ...
def tensor_array_read_v2_eager_fallback(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_read_v3(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ...): ...
def tensor_array_read_v3_eager_fallback(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_scatter(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_scatter_v2(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_scatter_v2_eager_fallback(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_scatter_v3(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_scatter_v3_eager_fallback(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_size(handle: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_size_v2(handle: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_size_v2_eager_fallback(handle: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_size_v3(handle: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_size_v3_eager_fallback(handle: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_split(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_split_v2(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_split_v2_eager_fallback(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_split_v3(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_split_v3_eager_fallback(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_unpack(handle: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_v2(size: Any, dtype: Any, element_shape: Optional[Any] = ..., dynamic_size: bool = ..., clear_after_read: bool = ..., tensor_array_name: str = ..., name: Optional[Any] = ...): ...
def tensor_array_v2_eager_fallback(size: Any, dtype: Any, element_shape: Optional[Any] = ..., dynamic_size: bool = ..., clear_after_read: bool = ..., tensor_array_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...

# _TensorArrayV3Output = namedtuple('TensorArrayV3', <ERROR>)

def tensor_array_v3(size: Any, dtype: Any, element_shape: Optional[Any] = ..., dynamic_size: bool = ..., clear_after_read: bool = ..., identical_element_shapes: bool = ..., tensor_array_name: str = ..., name: Optional[Any] = ...): ...
def tensor_array_v3_eager_fallback(size: Any, dtype: Any, element_shape: Optional[Any] = ..., dynamic_size: bool = ..., clear_after_read: bool = ..., identical_element_shapes: bool = ..., tensor_array_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_write(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_write_v2(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_write_v2_eager_fallback(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def tensor_array_write_v3(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...
def tensor_array_write_v3_eager_fallback(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def unstage(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...
def unstage_eager_fallback(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
