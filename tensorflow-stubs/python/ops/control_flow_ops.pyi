# Stubs for tensorflow.python.ops.control_flow_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.python.ops.gen_control_flow_ops import *
import abc as abc
from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2
from tensorflow.core.protobuf import control_flow_pb2 as control_flow_pb2
from tensorflow.python.eager import context as context
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, errors as errors, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, cond_v2_impl as cond_v2_impl, gen_array_ops as gen_array_ops, gen_control_flow_ops as gen_control_flow_ops, gen_data_flow_ops as gen_data_flow_ops, gen_logging_ops as gen_logging_ops, gen_resource_variable_ops as gen_resource_variable_ops, math_ops as math_ops, tensor_array_ops as tensor_array_ops
from tensorflow.python.util import compat as compat, deprecation as deprecation, nest as nest, tf_should_use as tf_should_use
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

ENABLE_COND_V2: Any
ENABLE_WHILE_V2: Any

def Assert(condition: Any, data: Any, summarize: Optional[Any] = ..., name: Optional[Any] = ...): ...
def exit(data: Any, name: Optional[Any] = ...): ...
def switch(data: Any, pred: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def merge(inputs: Any, name: Optional[Any] = ...): ...
def GetMaxSizeFromNestedMaximumIterations(value: Any, while_ctxt: Any): ...

class GradLoopState:
    def __init__(self, forward_ctxt: Any, outer_grad_state: Any) -> None: ...
    @property
    def outer_grad_state(self): ...
    @property
    def forward_context(self): ...
    @property
    def forward_index(self): ...
    @property
    def forward_sync(self): ...
    @property
    def grad_context(self): ...
    @property
    def grad_index(self): ...
    @property
    def grad_sync(self): ...
    @property
    def history_map(self): ...
    @property
    def switch_map(self): ...
    @property
    def unused_exits(self): ...
    @property
    def deferred_exits(self): ...
    @property
    def forward_loop_exits(self): ...
    @property
    def pending_exits_count(self): ...
    @pending_exits_count.setter
    def pending_exits_count(self, cnt: Any) -> None: ...
    def AddForwardAccumulator(self, value: Any, dead_branch: bool = ...): ...
    def AddBackpropAccumulatedValue(self, history_value: Any, value: Any, dead_branch: bool = ...): ...
    def GetRealValue(self, value: Any): ...

class ControlFlowState:
    def __init__(self) -> None: ...
    def GetGradState(self, op: Any, before: Any): ...
    def ProcessUnusedLoopExits(self, pending_count: Any, to_ops_set: Any): ...
    def EnterGradWhileContext(self, op: Any, before: Any) -> None: ...
    def ExitGradWhileContext(self, op: Any, before: Any) -> None: ...
    def AddWhileContext(self, op: Any, between_op_list: Any, between_ops: Any) -> None: ...
    def ZerosLikeForExit(self, val: Any): ...
    def ZerosLike(self, op: Any, index: Any): ...
    def PostProcessing(self) -> None: ...

def MaybeCreateControlFlowState(between_op_list: Any, between_ops: Any, colocate_gradients_with_ops: Any): ...
def ZerosLikeOutsideLoop(op: Any, index: Any): ...

class ControlFlowContext(metaclass=abc.ABCMeta):
    def __init__(self, values_def: Optional[Any] = ..., import_scope: Optional[Any] = ...) -> None: ...
    @property
    def name(self): ...
    @property
    def outer_context(self): ...
    @property
    def grad_state(self) -> None: ...
    @property
    def back_prop(self) -> None: ...
    @abc.abstractmethod
    def to_control_flow_context_def(self, context_def: Any, export_scope: Optional[Any] = ...) -> Any: ...
    def AddName(self, name: Any) -> None: ...
    def Enter(self) -> None: ...
    def Exit(self) -> None: ...
    def EnterGradientColocation(self, op: Any, gradient_uid: Any) -> None: ...
    def ExitGradientColocation(self, op: Any, gradient_uid: Any) -> None: ...
    def ExitResult(self, result: Any): ...
    def GetWhileContext(self): ...
    def AddInnerOp(self, op: Any) -> None: ...
    def GetControlPivot(self) -> None: ...
    def IsWhileContext(self): ...
    def IsCondContext(self): ...
    def IsXLAContext(self): ...

class CondContext(ControlFlowContext):
    def __init__(self, pred: Optional[Any] = ..., pivot: Optional[Any] = ..., branch: Optional[Any] = ..., name: str = ..., context_def: Optional[Any] = ..., import_scope: Optional[Any] = ...) -> None: ...
    @property
    def pred(self): ...
    @property
    def pivot(self): ...
    @property
    def branch(self): ...
    @property
    def grad_state(self): ...
    @property
    def back_prop(self): ...
    def GetControlPivot(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...): ...
    @staticmethod
    def from_proto(context_def: Any, import_scope: Optional[Any] = ...): ...
    def to_control_flow_context_def(self, context_def: Any, export_scope: Optional[Any] = ...) -> None: ...
    def AddValue(self, val: Any): ...
    def AddOp(self, op: Any) -> None: ...
    def BuildCondBranch(self, fn: Any): ...
    def IsCondContext(self): ...

def cond(pred: Any, true_fn: Optional[Any] = ..., false_fn: Optional[Any] = ..., strict: bool = ..., name: Optional[Any] = ..., fn1: Optional[Any] = ..., fn2: Optional[Any] = ...): ...

class WhileContext(ControlFlowContext):
    def __init__(self, maximum_iterations: Optional[Any] = ..., parallel_iterations: int = ..., back_prop: bool = ..., swap_memory: bool = ..., name: str = ..., grad_state: Optional[Any] = ..., context_def: Optional[Any] = ..., import_scope: Optional[Any] = ...) -> None: ...
    @property
    def maximum_iterations(self): ...
    @property
    def parallel_iterations(self): ...
    @property
    def back_prop(self): ...
    @property
    def swap_memory(self): ...
    @property
    def pivot(self): ...
    @property
    def loop_enters(self): ...
    @property
    def loop_exits(self): ...
    @property
    def grad_state(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...): ...
    def to_control_flow_context_def(self, context_def: Any, export_scope: Optional[Any] = ...) -> None: ...
    @staticmethod
    def from_proto(context_def: Any, import_scope: Optional[Any] = ...): ...
    def GetWhileContext(self): ...
    def GetControlPivot(self): ...
    def AddValue(self, val: Any): ...
    def AddOp(self, op: Any) -> None: ...
    def AddForwardLoopCounter(self, outer_grad_state: Any): ...
    def AddBackpropLoopCounter(self, count: Any, outer_grad_state: Any): ...
    def AddBackpropAccumulator(self, op: Any, grad: Any): ...
    def AddBackpropIndexedSlicesAccumulator(self, op: Any, grad: Any): ...
    def BuildLoop(self, pred: Any, body: Any, loop_vars: Any, shape_invariants: Any, return_same_structure: Any): ...
    def IsWhileContext(self): ...

def while_loop(cond: Any, body: Any, loop_vars: Any, shape_invariants: Optional[Any] = ..., parallel_iterations: int = ..., back_prop: bool = ..., swap_memory: bool = ..., name: Optional[Any] = ..., maximum_iterations: Optional[Any] = ..., return_same_structure: bool = ...): ...
def with_dependencies(dependencies: Any, output_tensor: Any, name: Optional[Any] = ...): ...
def group(*inputs: Any, **kwargs: Any): ...
def tuple(tensors: Any, name: Optional[Any] = ..., control_inputs: Optional[Any] = ...): ...
def case(pred_fn_pairs: Any, default: Optional[Any] = ..., exclusive: bool = ..., strict: bool = ..., name: str = ...): ...

class XLAControlFlowContext(ControlFlowContext, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def IsXLAContext(self): ...
    def AddOp(self, _: Any) -> None: ...
    def AddValue(self, x: Any): ...

def from_control_flow_context_def(context_def: Any, import_scope: Optional[Any] = ...): ...
