# Stubs for tensorflow.python.ops.tensor_array_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.python.eager import context as context
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, errors_impl as errors_impl, ops as ops, tensor_shape as tensor_shape, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, gen_data_flow_ops as gen_data_flow_ops, math_ops as math_ops
from tensorflow.python.util import tf_should_use as tf_should_use
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

class _GraphTensorArray:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...) -> None: ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def handle(self): ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...): ...

class _EagerTensorArray:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...) -> None: ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def handle(self): ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...) -> None: ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...) -> None: ...

class TensorArray:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...) -> None: ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def handle(self): ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...): ...
