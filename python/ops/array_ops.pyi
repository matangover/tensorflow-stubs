# Stubs for tensorflow.python.ops.array_ops (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.python.ops.gen_array_ops import *
from tensorflow.python.eager import context as context
from tensorflow.python.framework import common_shapes as common_shapes, constant_op as constant_op, dtypes as dtypes, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_util as tensor_util
from tensorflow.python.framework.constant_op import constant as constant
from tensorflow.python.ops import gen_array_ops as gen_array_ops, gen_math_ops as gen_math_ops
from tensorflow.python.util import deprecation as deprecation, nest as nest
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any as Any, Optional as Optional

newaxis: Any

def identity(input: Any, name: Optional[Any] = ...): ...
def expand_dims(input: Any, axis: Optional[Any] = ..., name: Optional[Any] = ..., dim: Optional[Any] = ...): ...
def listdiff(x: Any, y: Any, out_idx: Optional[Any] = ..., name: Optional[Any] = ...): ...
def setdiff1d(x: Any, y: Any, index_dtype: Any = ..., name: Optional[Any] = ...): ...
def broadcast_dynamic_shape(shape_x: Any, shape_y: Any): ...
def broadcast_static_shape(shape_x: Any, shape_y: Any): ...
def shape(input: Any, name: Optional[Any] = ..., out_type: Any = ...): ...
def shape_internal(input: Any, name: Optional[Any] = ..., optimize: bool = ..., out_type: Any = ...): ...
def shape_n(input: Any, out_type: Any = ..., name: Optional[Any] = ...): ...
def size(input: Any, name: Optional[Any] = ..., out_type: Any = ...): ...
def size_internal(input: Any, name: Optional[Any] = ..., optimize: bool = ..., out_type: Any = ...): ...
def rank(input: Any, name: Optional[Any] = ...): ...
def rank_internal(input: Any, name: Optional[Any] = ..., optimize: bool = ...): ...
def slice(input_: Any, begin: Any, size: Any, name: Optional[Any] = ...): ...
def strided_slice(input_: Any, begin: Any, end: Any, strides: Optional[Any] = ..., begin_mask: int = ..., end_mask: int = ..., ellipsis_mask: int = ..., new_axis_mask: int = ..., shrink_axis_mask: int = ..., var: Optional[Any] = ..., name: Optional[Any] = ...): ...
def parallel_stack(values: Any, name: str = ...): ...
def stack(values: Any, axis: int = ..., name: str = ...): ...
def unstack(value: Any, num: Optional[Any] = ..., axis: int = ..., name: str = ...): ...
def concat(values: Any, axis: Any, name: str = ...): ...
def boolean_mask(tensor: Any, mask: Any, name: str = ..., axis: Optional[Any] = ...): ...
def sparse_mask(a: Any, mask_indices: Any, name: Optional[Any] = ...): ...
def unique(x: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...
def unique_with_counts(x: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...
def split(value: Any, num_or_size_splits: Any, axis: int = ..., num: Optional[Any] = ..., name: str = ...): ...
def transpose(a: Any, perm: Optional[Any] = ..., name: str = ..., conjugate: bool = ...): ...
def matrix_transpose(a: Any, name: str = ..., conjugate: bool = ...): ...
def zeros(shape: Any, dtype: Any = ..., name: Optional[Any] = ...): ...
def zeros_like(tensor: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., optimize: bool = ...): ...
def ones_like(tensor: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., optimize: bool = ...): ...
def ones(shape: Any, dtype: Any = ..., name: Optional[Any] = ...): ...
def placeholder(dtype: Any, shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def sparse_placeholder(dtype: Any, shape: Optional[Any] = ..., name: Optional[Any] = ...): ...
def pad(tensor: Any, paddings: Any, mode: str = ..., name: Optional[Any] = ..., constant_values: Any = ...): ...
def meshgrid(*args: Any, **kwargs: Any): ...

NEW_AXIS: int
SHRINK_AXIS: int

def edit_distance(hypothesis: Any, truth: Any, normalize: bool = ..., name: str = ...): ...
def required_space_to_batch_paddings(input_shape: Any, block_shape: Any, base_paddings: Optional[Any] = ..., name: Optional[Any] = ...): ...
def space_to_batch(input: Any, paddings: Any, block_size: Any, name: Optional[Any] = ...): ...
def space_to_depth(input: Any, block_size: Any, name: Optional[Any] = ..., data_format: str = ...): ...
def depth_to_space(input: Any, block_size: Any, name: Optional[Any] = ..., data_format: str = ...): ...
def batch_to_space(input: Any, crops: Any, block_size: Any, name: Optional[Any] = ...): ...
def one_hot(indices: Any, depth: Any, on_value: Optional[Any] = ..., off_value: Optional[Any] = ..., axis: Optional[Any] = ..., dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def sequence_mask(lengths: Any, maxlen: Optional[Any] = ..., dtype: Any = ..., name: Optional[Any] = ...): ...
def squeeze(input: Any, axis: Optional[Any] = ..., name: Optional[Any] = ..., squeeze_dims: Optional[Any] = ...): ...
def where(condition: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., name: Optional[Any] = ...): ...
def reverse_sequence(input: Any, seq_lengths: Any, seq_axis: Optional[Any] = ..., batch_axis: Optional[Any] = ..., name: Optional[Any] = ..., seq_dim: Optional[Any] = ..., batch_dim: Optional[Any] = ...): ...
def gather(params: Any, indices: Any, validate_indices: Optional[Any] = ..., name: Optional[Any] = ..., axis: int = ...): ...
def batch_gather(params: Any, indices: Any, name: Optional[Any] = ...): ...
def quantize_v2(input: Any, min_range: Any, max_range: Any, T: Any, mode: str = ..., name: Optional[Any] = ..., round_mode: str = ...): ...
def quantize(input: Any, min_range: Any, max_range: Any, T: Any, mode: str = ..., round_mode: str = ..., name: Optional[Any] = ...): ...
def searchsorted(sorted_sequence: Any, values: Any, side: str = ..., out_type: Any = ..., name: Optional[Any] = ...): ...
