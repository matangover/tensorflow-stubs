# Stubs for tensorflow.contrib.distribute.python.values (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from collections import namedtuple as namedtuple
from tensorflow.contrib.distribute.python import input_ops as input_ops, prefetching_ops_v2 as prefetching_ops_v2
from tensorflow.python.eager import context as context, tape as tape
from tensorflow.python.framework import ops as ops, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, gen_resource_variable_ops as gen_resource_variable_ops, math_ops as math_ops
from tensorflow.python.training import device_util as device_util, distribution_strategy_context as distribution_strategy_context, saver as saver
from tensorflow.python.training.checkpointable import base as checkpointable
from tensorflow.python.util import nest as nest
from typing import Any as Any, Optional as Optional

class DistributedValues:
    def __init__(self, index: Any) -> None: ...
    def get(self, device: Optional[Any] = ...): ...
    def on_device(self, device: Any): ...
    @property
    def devices(self): ...
    @property
    def is_tensor_like(self): ...

class DistributedDelegate(DistributedValues):
    def __init__(self, index: Any) -> None: ...
    def __getattr__(self, name: Any): ...
    def __add__(self, o: Any): ...
    def __radd__(self, o: Any): ...
    def __sub__(self, o: Any): ...
    def __rsub__(self, o: Any): ...
    def __mul__(self, o: Any): ...
    def __rmul__(self, o: Any): ...
    def __truediv__(self, o: Any): ...
    def __rtruediv__(self, o: Any): ...
    def __floordiv__(self, o: Any): ...
    def __rfloordiv__(self, o: Any): ...
    def __mod__(self, o: Any): ...
    def __rmod__(self, o: Any): ...
    def __lt__(self, o: Any): ...
    def __le__(self, o: Any): ...
    def __gt__(self, o: Any): ...
    def __ge__(self, o: Any): ...
    def __and__(self, o: Any): ...
    def __rand__(self, o: Any): ...
    def __or__(self, o: Any): ...
    def __ror__(self, o: Any): ...
    def __xor__(self, o: Any): ...
    def __rxor__(self, o: Any): ...
    def __getitem__(self, o: Any): ...
    def __pow__(self, o: Any, modulo: Optional[Any] = ...): ...
    def __rpow__(self, o: Any): ...
    def __invert__(self): ...
    def __neg__(self): ...
    def __abs__(self): ...
    def __div__(self, o: Any): ...
    def __rdiv__(self, o: Any): ...
    def __matmul__(self, o: Any): ...
    def __rmatmul__(self, o: Any): ...

class PerDevice(DistributedValues): ...
class Mirrored(DistributedDelegate): ...

DistributedVarOp = namedtuple('DistributedVarOp', ['name', 'graph', 'type'])

class DistributedVariable(DistributedDelegate):
    def __init__(self, index: Any) -> None: ...
    def is_initialized(self, name: Optional[Any] = ...): ...
    @property
    def initializer(self): ...
    @property
    def graph(self): ...
    @property
    def name(self): ...
    @property
    def dtype(self): ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...): ...
    @property
    def op(self): ...
    def read_value(self): ...

class _MirroredSaveable(saver.BaseSaverBuilder.ResourceVariableSaveable):
    def __init__(self, mirrored_variable: Any, primary_variable: Any, name: Any) -> None: ...
    def restore(self, restored_tensors: Any, restored_shapes: Any): ...

class MirroredVariable(DistributedVariable, Mirrored, checkpointable.CheckpointableBase):
    def __init__(self, index: Any, primary_var: Any, aggregation: Any) -> None: ...
    def assign_sub(self, *args: Any, **kwargs: Any): ...
    def assign_add(self, *args: Any, **kwargs: Any): ...
    def assign(self, *args: Any, **kwargs: Any): ...
    @property
    def aggregation(self): ...

class TPUMirroredVariable(checkpointable.CheckpointableBase):
    def __init__(self, index: Any, primary_var: Any, aggregation: Any) -> None: ...
    def __add__(self, o: Any): ...
    def __radd__(self, o: Any): ...
    def __sub__(self, o: Any): ...
    def __rsub__(self, o: Any): ...
    def __mul__(self, o: Any): ...
    def __rmul__(self, o: Any): ...
    def __truediv__(self, o: Any): ...
    def __rtruediv__(self, o: Any): ...
    def __floordiv__(self, o: Any): ...
    def __rfloordiv__(self, o: Any): ...
    def __mod__(self, o: Any): ...
    def __rmod__(self, o: Any): ...
    def __lt__(self, o: Any): ...
    def __le__(self, o: Any): ...
    def __gt__(self, o: Any): ...
    def __ge__(self, o: Any): ...
    def __and__(self, o: Any): ...
    def __rand__(self, o: Any): ...
    def __or__(self, o: Any): ...
    def __ror__(self, o: Any): ...
    def __xor__(self, o: Any): ...
    def __rxor__(self, o: Any): ...
    def __getitem__(self, o: Any): ...
    def __pow__(self, o: Any, modulo: Optional[Any] = ...): ...
    def __rpow__(self, o: Any): ...
    def __invert__(self): ...
    def __neg__(self): ...
    def __abs__(self): ...
    def __div__(self, o: Any): ...
    def __rdiv__(self, o: Any): ...
    def __matmul__(self, o: Any): ...
    def __rmatmul__(self, o: Any): ...
    @property
    def handle(self): ...
    @property
    def device(self): ...
    @property
    def trainable(self): ...
    def read_value(self): ...
    def assign_sub(self, *args: Any, **kwargs: Any): ...
    def assign_add(self, *args: Any, **kwargs: Any): ...
    def assign(self, *args: Any, **kwargs: Any): ...
    @property
    def aggregation(self): ...
    @property
    def constraint(self) -> None: ...
    @property
    def initializer(self): ...
    @property
    def graph(self): ...
    @property
    def name(self): ...
    @property
    def dtype(self): ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...): ...
    @property
    def op(self): ...
    def is_initialized(self, name: Optional[Any] = ...): ...

class _TowerLocalSaveable(saver.BaseSaverBuilder.SaveableObject):
    def __init__(self, tower_local_variable: Any, name: Any) -> None: ...
    def restore(self, restored_tensors: Any, restored_shapes: Any): ...

class TowerLocalVariable(DistributedVariable, PerDevice, checkpointable.CheckpointableBase):
    def __init__(self, index: Any, primary_var: Any, aggregation: Any) -> None: ...
    def assign_sub(self, *args: Any, **kwargs: Any): ...
    def assign_add(self, *args: Any, **kwargs: Any): ...
    def assign(self, *args: Any, **kwargs: Any): ...
    @property
    def aggregation(self): ...

def regroup(per_device: Any, wrap_class: Any = ...): ...
def select_device(device: Any, structured: Any): ...
def select_device_mirrored(device: Any, structured: Any): ...
def update_regroup(strategy: Any, updates: Any, should_group: Any): ...

class PerDeviceDataIterator:
    def __init__(self, iterator: Any, devices: Any, prefetch_on_device: Optional[Any] = ...) -> None: ...
    @property
    def initializer(self): ...
    def get_next(self, name: Optional[Any] = ...): ...

class PerDeviceDataset:
    def __init__(self, dataset: Any, devices: Any, prefetch_on_device: Optional[Any] = ...) -> None: ...
    def make_one_shot_iterator(self): ...
    def make_initializable_iterator(self): ...

class MultiWorkerDataIterator:
    def __init__(self, iterators: Any, worker_device_map: Any) -> None: ...
    @property
    def initializer(self): ...
    def get_next(self, name: Optional[Any] = ...): ...

class MultiWorkerDataset:
    def __init__(self, dataset_fn: Any, worker_device_map: Any, prefetch_on_device: Optional[Any] = ..., auto_shard: bool = ...) -> None: ...
    def make_one_shot_iterator(self): ...
    def make_initializable_iterator(self): ...

class _PerKey:
    def __init__(self, *index: Any) -> None: ...
    def get(self, iteration: Any): ...
    def get_shape(self): ...
    def get_dtype(self): ...

class PerIteration(_PerKey):
    def __init__(self, *index: Any) -> None: ...

class Batches(_PerKey): ...

class MultiIterator:
    def __init__(self, dataset_iterator: Any, iterations: Any, batches_per_iteration: Any) -> None: ...
    def get_next(self, name: Optional[Any] = ...): ...
    @property
    def initializer(self): ...

class PerIterationDataset:
    def __init__(self, dataset: Any, iterations: Any, batches_per_iteration: Any) -> None: ...
    def make_one_shot_iterator(self): ...
    def make_initializable_iterator(self): ...

class MapOutput:
    def __init__(self, l: Any) -> None: ...
    def get(self): ...

class MultiStepContext:
    def __init__(self) -> None: ...
    @property
    def last_step_outputs(self): ...
    def set_last_step_output(self, name: Any, output: Any, aggregation: Any = ...) -> None: ...
    @property
    def non_tensor_outputs(self): ...
    def set_non_tensor_output(self, name: Any, output: Any) -> None: ...

def value_container(val: Any): ...

class AggregatingVariable(checkpointable.CheckpointableBase):
    def __init__(self, v: Any, aggregation: Any) -> None: ...
    def get(self): ...
    def __getattr__(self, name: Any): ...
    def assign_sub(self, *args: Any, **kwargs: Any): ...
    def assign_add(self, *args: Any, **kwargs: Any): ...
    def assign(self, *args: Any, **kwargs: Any): ...
    @property
    def aggregation(self): ...
    @property
    def name(self): ...
    @property
    def dtype(self): ...
    def __add__(self, o: Any): ...
    def __radd__(self, o: Any): ...
    def __sub__(self, o: Any): ...
    def __rsub__(self, o: Any): ...
    def __mul__(self, o: Any): ...
    def __rmul__(self, o: Any): ...
    def __truediv__(self, o: Any): ...
    def __rtruediv__(self, o: Any): ...
    def __floordiv__(self, o: Any): ...
    def __rfloordiv__(self, o: Any): ...
    def __mod__(self, o: Any): ...
    def __rmod__(self, o: Any): ...
    def __lt__(self, o: Any): ...
    def __le__(self, o: Any): ...
    def __gt__(self, o: Any): ...
    def __ge__(self, o: Any): ...
    def __and__(self, o: Any): ...
    def __rand__(self, o: Any): ...
    def __or__(self, o: Any): ...
    def __ror__(self, o: Any): ...
    def __xor__(self, o: Any): ...
    def __rxor__(self, o: Any): ...
    def __getitem__(self, o: Any): ...
    def __pow__(self, o: Any, modulo: Optional[Any] = ...): ...
    def __rpow__(self, o: Any): ...
    def __invert__(self): ...
    def __neg__(self): ...
    def __abs__(self): ...
    def __div__(self, o: Any): ...
    def __rdiv__(self, o: Any): ...
    def __matmul__(self, o: Any): ...
    def __rmatmul__(self, o: Any): ...
