# Stubs for tensorflow.contrib.learn.python.learn.monitors (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tensorflow.core.framework.summary_pb2 import Summary as Summary
from tensorflow.core.util.event_pb2 import SessionLog as SessionLog
from tensorflow.python.framework import ops as ops
from tensorflow.python.training import checkpoint_management as checkpoint_management, session_run_hook as session_run_hook, training_util as training_util
from tensorflow.python.util import deprecation as deprecation, tf_inspect as tf_inspect
from typing import Any as Any, Optional as Optional

class BaseMonitor:
    def __init__(self) -> None: ...
    @property
    def run_on_all_workers(self): ...
    def set_estimator(self, estimator: Any) -> None: ...
    def begin(self, max_steps: Optional[Any] = ...) -> None: ...
    def end(self, session: Optional[Any] = ...) -> None: ...
    def epoch_begin(self, epoch: Any) -> None: ...
    def epoch_end(self, epoch: Any) -> None: ...
    def step_begin(self, step: Any): ...
    def step_end(self, step: Any, output: Any): ...
    def post_step(self, step: Any, session: Any) -> None: ...

class EveryN(BaseMonitor):
    def __init__(self, every_n_steps: int = ..., first_n_steps: int = ...) -> None: ...
    def every_n_step_begin(self, step: Any): ...
    def every_n_step_end(self, step: Any, outputs: Any): ...
    def every_n_post_step(self, step: Any, session: Any) -> None: ...
    def step_begin(self, step: Any): ...
    def step_end(self, step: Any, output: Any): ...
    def post_step(self, step: Any, session: Any) -> None: ...
    def end(self, session: Optional[Any] = ...) -> None: ...

class StopAtStep(BaseMonitor):
    def __init__(self, num_steps: Optional[Any] = ..., last_step: Optional[Any] = ...) -> None: ...
    @property
    def run_on_all_workers(self): ...
    def step_begin(self, step: Any): ...
    def step_end(self, step: Any, output: Any): ...

class PrintTensor(EveryN):
    def __init__(self, tensor_names: Any, every_n: int = ..., first_n: int = ...) -> None: ...
    def every_n_step_begin(self, step: Any): ...
    def every_n_step_end(self, step: Any, outputs: Any) -> None: ...

class LoggingTrainable(EveryN):
    def __init__(self, scope: Optional[Any] = ..., every_n: int = ..., first_n: int = ...) -> None: ...
    def every_n_step_begin(self, step: Any): ...
    def every_n_step_end(self, step: Any, outputs: Any) -> None: ...

class SummarySaver(EveryN):
    def __init__(self, summary_op: Any, save_steps: int = ..., output_dir: Optional[Any] = ..., summary_writer: Optional[Any] = ..., scaffold: Optional[Any] = ...) -> None: ...
    def set_estimator(self, estimator: Any) -> None: ...
    def every_n_step_begin(self, step: Any): ...
    def every_n_step_end(self, step: Any, outputs: Any): ...
    def end(self, session: Optional[Any] = ...) -> None: ...

class ValidationMonitor(EveryN):
    x: Any = ...
    y: Any = ...
    input_fn: Any = ...
    batch_size: Any = ...
    eval_steps: Any = ...
    metrics: Any = ...
    hooks: Any = ...
    early_stopping_rounds: Any = ...
    early_stopping_metric: Any = ...
    early_stopping_metric_minimize: Any = ...
    name: Any = ...
    def __init__(self, x: Optional[Any] = ..., y: Optional[Any] = ..., input_fn: Optional[Any] = ..., batch_size: Optional[Any] = ..., eval_steps: Optional[Any] = ..., every_n_steps: int = ..., metrics: Optional[Any] = ..., hooks: Optional[Any] = ..., early_stopping_rounds: Optional[Any] = ..., early_stopping_metric: str = ..., early_stopping_metric_minimize: bool = ..., name: Optional[Any] = ..., check_interval_secs: int = ...) -> None: ...
    @property
    def early_stopped(self): ...
    @property
    def best_step(self): ...
    @property
    def best_value(self): ...
    @property
    def best_metrics(self): ...
    def every_n_step_end(self, step: Any, outputs: Any): ...

class CaptureVariable(EveryN):
    def __init__(self, var_name: Any, every_n: int = ..., first_n: int = ...) -> None: ...
    @property
    def values(self): ...
    def every_n_step_begin(self, step: Any): ...
    def every_n_step_end(self, step: Any, outputs: Any) -> None: ...

def get_default_monitors(loss_op: Optional[Any] = ..., summary_op: Optional[Any] = ..., save_summary_steps: int = ..., output_dir: Optional[Any] = ..., summary_writer: Optional[Any] = ...): ...

class GraphDump(BaseMonitor):
    IGNORE_OPS: Any = ...
    def __init__(self, ignore_ops: Optional[Any] = ...) -> None: ...
    def begin(self, max_steps: Optional[Any] = ...) -> None: ...
    def step_begin(self, step: Any): ...
    def step_end(self, step: Any, output: Any) -> None: ...
    @property
    def data(self): ...
    def compare(self, other_dump: Any, step: Any, atol: float = ...): ...

class ExportMonitor(EveryN):
    def __init__(self, every_n_steps: Any, export_dir: Any, input_fn: Optional[Any] = ..., input_feature_key: Optional[Any] = ..., exports_to_keep: int = ..., signature_fn: Optional[Any] = ..., default_batch_size: int = ...) -> None: ...
    @property
    def export_dir(self): ...
    @property
    def exports_to_keep(self): ...
    @property
    def signature_fn(self): ...
    @property
    def last_export_dir(self): ...
    def every_n_step_end(self, step: Any, outputs: Any) -> None: ...
    def end(self, session: Optional[Any] = ...) -> None: ...

class CheckpointSaver(BaseMonitor):
    def __init__(self, checkpoint_dir: Any, save_secs: Optional[Any] = ..., save_steps: Optional[Any] = ..., saver: Optional[Any] = ..., checkpoint_basename: str = ..., scaffold: Optional[Any] = ...) -> None: ...
    def begin(self, max_steps: Optional[Any] = ...) -> None: ...
    def step_begin(self, step: Any) -> None: ...
    def post_step(self, step: Any, session: Any) -> None: ...
    def end(self, session: Optional[Any] = ...) -> None: ...

class StepCounter(EveryN):
    def __init__(self, every_n_steps: int = ..., output_dir: Optional[Any] = ..., summary_writer: Optional[Any] = ...) -> None: ...
    def set_estimator(self, estimator: Any) -> None: ...
    def every_n_step_end(self, current_step: Any, outputs: Any) -> None: ...

class NanLossDuringTrainingError(RuntimeError): ...

class NanLoss(EveryN):
    def __init__(self, loss_tensor: Any, every_n_steps: int = ..., fail_on_nan_loss: bool = ...) -> None: ...
    def every_n_step_begin(self, step: Any): ...
    def every_n_step_end(self, step: Any, outputs: Any): ...

class RunHookAdapterForMonitors(session_run_hook.SessionRunHook):
    def __init__(self, monitors: Any) -> None: ...
    def begin(self) -> None: ...
    def before_run(self, run_context: Any): ...
    def after_run(self, run_context: Any, run_values: Any) -> None: ...
    def end(self, session: Any) -> None: ...

def replace_monitors_with_hooks(monitors_or_hooks: Any, estimator: Any): ...
